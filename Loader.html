<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Andries Test</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		
	</head>

	<body style="background-color:#f5f5f5">
		<div id="info">
			<a>
				Here we want to load a obj/mtl file and decimate it and then export it
			</a>
			<div>
				Add files here:<input type="file" name="FileUpload" id="FileUpload" multiple/>
			</div>

			<button type="button" id='glbDownload'>DOWNLOAD AS GLB</button>
		</div>

		<script type="module">
			
			//imports needed for the scripts to work
			//import * as THREE from 'https://threejs.org/build/three.module.js';
			import * as THREE from '/js/newthree.module.js';

			//this is out camera controls
			//import { OrbitControls } from 'https://unpkg.com/three@0.120.1/examples/jsm/controls/OrbitControls.js';
			import { OrbitControls } from '/js/OrbitControls.js';

			//this script allows us to load an OBJ file
			//import { OBJLoader } from 'https://threejs.org/examples/jsm/loaders/OBJLoader.js';
			import { OBJLoader } from '/js/OBJLoader.js';
			//This script allows us to load a mtl file
			//import { MTLLoader } from 'https://threejs.org/examples/jsm/loaders/MTLLoader.js';
			import { MTLLoader } from '/js/MTLLoader.js';
			
			import { GLTFLoader } from 'https://threejs.org/examples/jsm/loaders/GLTFLoader.js';

			//this script allows us to export/save the file as a GLB
			//import { GLTFExporter } from 'https://threejs.org/examples/jsm/exporters/GLTFExporter.js';
			import { GLTFExporter } from '/js/GLTFExporter.js';

			//Create Scene
			let scene, perspectiveCamera, renderer;

			var modelName = '';

			var loader;

			var textureLoader = new THREE.TextureLoader();

			var upload = document.getElementById('FileUpload');
			

			function init() 
			{
				
				scene = new THREE.Scene();

				const backgroundcolor = 0x727272;
				scene.background = new THREE.Color(backgroundcolor);

				const fov = 60;
				const aspect = window.innerWidth/window.innerHeight;
				const near = 0.1;
				const far = 5000;

				perspectiveCamera = new THREE.PerspectiveCamera( fov, aspect, near, far );
				perspectiveCamera.position.z = 3500;


				const ambientLight = new THREE.AmbientLight( 0xc9c9c9, 0.3 );
				scene.add( ambientLight );

				const pointLight = new THREE.PointLight( 0xffffff, 0.5 );
				perspectiveCamera.add( pointLight );
				scene.add( perspectiveCamera );

				//end of lighting

				renderer = new THREE.WebGLRenderer({antialias:true});
				renderer.setSize(window.innerWidth,window.innerHeight);
				renderer.outputEncoding = THREE.sRGBEncoding;
				document.body.appendChild(renderer.domElement);

				animate();
			
				const controls = new OrbitControls(perspectiveCamera, renderer.domElement);
				controls.target.set(0,0.9,0);

				//controls.update() must be called after any manual changes to the camera's transform
				controls.update();
			}
			
			//Add the models to view to the viewer
			function animate() 
			{
				perspectiveCamera.updateProjectionMatrix();
				renderer.render(scene,perspectiveCamera);
				requestAnimationFrame(animate);
			}

			//Export of the glb starts here
			function exportGLTF( input ) 
			{
				const gltfExporter = new GLTFExporter();

				//options to det for the download
				const options = 
				{
					trs: true,
					onlyVisible: true,
					truncateDrawRange: true,
					binary: true,
					maxTextureSize: 0 || Infinity // To prevent NaN value
				};

				gltfExporter.parse( input, function ( result ) 
				{

					if ( result instanceof ArrayBuffer ) 
					{
						saveArrayBuffer( result, modelName + '.glb' );
					} 
					else 
					{
						const output = JSON.stringify( result, null, 2 );
						console.log( output );
						saveString( output, modelName + '.gltf' );
					}

				}, options );

			}

			//calls the save file and sets the type of file for download
			function saveArrayBuffer( buffer, filename ) 
			{
				save( new Blob( [ buffer ], { type: 'application/octet-stream' } ), filename );
			}

			//this click a button that gets created for a firefox workaround
			function save( blob, filename ) 
			{

				link.href = URL.createObjectURL( blob );
				link.download = filename;
				link.click();
			}

			

			//Creates a download link to download the file
			const link = document.createElement( 'a' );
			link.style.display = 'none';
			document.body.appendChild( link );

			init();

			document.getElementById( 'glbDownload' ).addEventListener( 'click', function () 
			{
				exportGLTF( scene );
			} );

			function onFile() {
            var me = this;
			var file = upload.files[0];
			var uploadArray = upload.files;

			var fullname = '';
			var fileSize = 0;
			var modelFile = 0;
			var materialFile = 0;
			var modelImages = [];
			var modelImageNames = [];

			for (var i = 0; i < uploadArray.length; i++) 
			{
				var modelNameAndExtention = uploadArray[i].name;

				if(modelNameAndExtention.includes(".glb") || modelNameAndExtention.includes(".obj") ||modelNameAndExtention.includes(".stl") || modelNameAndExtention.includes(".fbx") || modelNameAndExtention.includes(".3ds"))
				{
					modelFile = i;
					fullname = uploadArray[i].name;
					fileSize = uploadArray[i].size;
				}
				else if(modelNameAndExtention.includes(".mtl"))
				{
					materialFile = i;
				}
				else
				{
					modelImages.push(URL.createObjectURL(upload.files[i]));
					modelImageNames = upload.files[i].name;
				}
    			
			}

            if (modelFile != null)
            {
                if (fileSize < (25000 * 1024))
                {

					console.log("File has been loaded");

					var modelPath  = URL.createObjectURL(upload.files[modelFile]);
					var modelMaterialPath  = URL.createObjectURL(upload.files[materialFile]);

					//obj loader
					if(fullname.includes(".obj") || fullname.includes(".OBJ"))
					{
						loader = new MTLLoader();

						let objLoader = new OBJLoader();

						try
						{
							loader.load(modelMaterialPath, function(material)
							{
								material.preload();
								console.log(material.materials.length);


								objLoader.setMaterials( material ).load(modelPath, function(object)
								{
									var texture;

									object.traverse( function( node ) 
									{
										
										
										for (var i = 0; i < modelImages.length; i++) 
										{
											//console.log(modelImages[i]);
											//texture = new THREE.TextureLoader().load(modelImages[i]);
										}

										if (node instanceof THREE.Mesh) 
										{
											//node.material.map = texture;
										}
									});
									scene.add( object );
								});
							});
						}
						catch
						{
							console.log("No mtl file found");
							objLoader.load(modelPath, function(object)
							{
								object.traverse( function( node ) 
								{
									//add extra code here
								});
								scene.add( object );
							});
						}
					}

					//glb loader
					if(fullname.includes(".glb") || fullname.includes(".GLB"))
					{
						var modelPath  = URL.createObjectURL(upload.files[modelFile]);
						loader = new GLTFLoader();

						loader.load(modelPath, function(gltf)
						{
							gltf.scene.traverse( function( node ) 
							{
								//extra stuff can be added here
							});

							scene.add(gltf.scene);
						});
					}

					if(fullname.includes(".gltf") || fullname.includes(".GLTF"))
					{
						console.log("GLTF type uploaded");
					}

					if(fullname.includes(".stl") || fullname.includes(".STL"))
					{
						console.log("STL type uploaded");
					}

					if(fullname.includes(".fbx") || fullname.includes(".FBX"))
					{
						console.log("FBX type uploaded");
					}

					if(fullname.includes(".3ds") || fullname.includes(".3DS"))
					{
						console.log("3DS type uploaded");
					}

					animate();

					const controls = new OrbitControls(perspectiveCamera, renderer.domElement);
					controls.target.set(0,0.9,0);

					//controls.update() must be called after any manual changes to the camera's transform
					controls.update();

                }
                else
                {
                    window.alert('File size is too large, please ensure you are uploading a file of less than 25MB');
                }
            }
            else
            {
                window.alert('File type ' + file.type + ' not supported');
            }
        }

        upload.addEventListener('dragenter', function (e)
        {
            upload.parentNode.className = 'area dragging';
        }, false);

        upload.addEventListener('dragleave', function (e) {
            upload.parentNode.className = 'area';
        }, false);

        upload.addEventListener('dragdrop', function (e) {
            onFile();
        }, false);

        upload.addEventListener('change', function (e) {
            onFile();
            
        }, false);

		</script>
	</body>
</html>
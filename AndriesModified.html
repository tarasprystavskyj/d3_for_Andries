<!DOCTYPE html>
<html lang="en">

<head>
	<title>Andries Test</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">

</head>

<body style="background-color:#000">
	<a href="" download="">Download</a>
	<div class="drop-zone">
		<span class="drop-zone__prompt">Drop file here or click to upload</span>
		<input type="file" name="myFile" id="modal" class="drop-zone__input" required multiple>
	</div>
	<div id="info">
		<a>
			Here we want to load a obj/mtl file and decimate it and then export it
		</a>
		<input type="number" id='txtDecimate' value="40"></input>
		<button type="button" id='btnDecimate'>Decimate Model</button>
		<button type="button" id='glbDownload'>DOWNLOAD AS GLB</button>
		<div>
			<label>Number of Vertices:</label><input type="number" id='txtVertex' value="0" disabled></input>
			<label>Number of potential vertices:</label><input type="number" id='txtNewVertex' value="0"
				disabled></input>
		</div>
	</div>

	<script type="module">

		//imports needed for the scripts to work
		//import * as THREE from 'https://threejs.org/build/three.module.js';
		import * as THREE from '/js/newthree.module.js';

		//this is out camera controls
		//import { OrbitControls } from 'https://unpkg.com/three@0.120.1/examples/jsm/controls/OrbitControls.js';
		import { OrbitControls } from '/js/OrbitControls.js';

		//this script allows us to load an OBJ file
		//import { OBJLoader } from 'https://threejs.org/examples/jsm/loaders/OBJLoader.js';
		import { OBJLoader } from '/js/OBJLoader.js';
		//This script allows us to load a mtl file
		//import { MTLLoader } from 'https://threejs.org/examples/jsm/loaders/MTLLoader.js';
		import { MTLLoader } from '/js/MTLLoader.js';
		//this script merges obj and mtl files
		//import { DDSLoader } from'https://threejs.org/examples/jsm/loaders/DDSLoader.js';
		//import { DDSLoader } from'/js/DDSLoader.js';

		//this script allows us to export/save the file as a GLB
		//import { GLTFExporter } from 'https://threejs.org/examples/jsm/exporters/GLTFExporter.js';
		import { GLTFExporter } from '/js/GLTFExporter.js';

		//import { SimplifyModifier } from 'https://threejs.org/examples/jsm/modifiers/SimplifyModifier.js';
		//import { simplifyMesh } from '/js/SimplifyModifier3.js';
		import { SimplifyModifier } from '/js/SimplifyModifier.js';
		var modifier = new SimplifyModifier();

		import { Geometry } from "/js/Geometry.js";


		//Create Scene
		let scene, perspectiveCamera, renderer;

		var modelName = '';

		//Decimation options
		var modelWireframe = false;
		var decimateAmount = 1000;//any amount will do if it can be calculated

		var aggressivenessOfDecimation = 7;//How agressive edges are collapsed (standard is 7)
		var updateModel = 5;//Update mesh after ${update} iterations.lower values give better results (standard is 5)
		var recompute = false//Whether to recompute errors on each mesh update. Enable for best results.


		var model;
		modelName = 'Duck';
		var modelFolderPath = 'models/'

		// var modelPath = modelFolderPath + modelName + '.obj';
		// var mtlPath = modelFolderPath + modelName + '.mtl';

		var modelPath
		var mtlPath


		var newMaterial;
		var objectModel;

		//other settings
		//var modelMetalness = 0.5;
		//var modelOpacity = 1;
		//var modelRoughness = 1;
		//var modelAlphaTest = 0;
		//var modelDepthWrite = true;
		var modelVertexColors = false;
		var modelFlatShading = true;//material will 'hug' the model if set to true
		var modelWireframe = false;

		var meshMaterial;
		var meshMaterialMap;

		let mtlLoader = new MTLLoader();
		let objLoader = new OBJLoader();

		var textureLoader = new THREE.TextureLoader();


		// Paste Here 

		//Add the models to view to the viewer
		function animate() {
			perspectiveCamera.updateProjectionMatrix();
			renderer.render(scene, perspectiveCamera);
			requestAnimationFrame(animate);
		}

		//Export of the glb starts here
		function exportGLTF(input) {
			const gltfExporter = new GLTFExporter();

			//options to det for the download
			const options =
			{
				trs: true,
				onlyVisible: true,
				truncateDrawRange: true,
				binary: true,
				maxTextureSize: 0 || Infinity // To prevent NaN value
			};

			gltfExporter.parse(input, function (result) {

				if (result instanceof ArrayBuffer) {
					saveArrayBuffer(result, modelName + '.glb');
				}
				else {
					const output = JSON.stringify(result, null, 2);
					console.log(output);
					saveString(output, modelName + '.gltf');
				}

			}, options);

		}

		//calls the save file and sets the type of file for download
		function saveArrayBuffer(buffer, filename) {
			save(new Blob([buffer], { type: 'application/octet-stream' }), filename);
		}

		//this click a button that gets created for a firefox workaround
		function save(blob, filename) {

			link.href = URL.createObjectURL(blob);
			link.download = filename;
			link.click();
		}

		function init() {
			console.log('Init')
			scene = new THREE.Scene();

			const backgroundcolor = 0x727272;
			scene.background = new THREE.Color(backgroundcolor);

			const fov = 60;
			const aspect = window.innerWidth / window.innerHeight;
			const near = 0.1;
			const far = 40000;

			perspectiveCamera = new THREE.PerspectiveCamera(fov, aspect, near, far);
			perspectiveCamera.position.z = 1500;


			const ambientLight = new THREE.AmbientLight(0xc9c9c9, 0.3);
			scene.add(ambientLight);

			const pointLight = new THREE.PointLight(0xffffff, 0.5);
			perspectiveCamera.add(pointLight);
			scene.add(perspectiveCamera);

			//end of lighting

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.outputEncoding = THREE.sRGBEncoding;
			document.body.appendChild(renderer.domElement);

			var startVertexes = 0;


			mtlLoader.load(mtlPath, function (material) {
				console.log('material', material)
				material.preload();

				newMaterial = material;

				objLoader.setMaterials(material).load(modelPath, function (object) {
					object.position.y = 0;
					objectModel = object;


					var box = new THREE.Box3().setFromObject(objectModel);
					console.log('Size', box.min, box.max, box.getSize());


					var modelZ = box.getSize().z
					var modelMinZ = box.min.z
					var modelMaxZ = box.max.z

					var cameraPos = modelZ + modelMinZ + modelMaxZ
					var cameraPosX = box.getSize().x
					var cameraPosY = box.getSize().y

					if (cameraPos < 100) {
						cameraPos = cameraPos * 1.5
					}
					else {
						cameraPos = cameraPos / 4
						objectModel.rotateY(232.5)
						objectModel.rotateX(181)
					}


					perspectiveCamera.position.z = cameraPos;
					//perspectiveCamera.position.x = -21110;
					//perspectiveCamera.position.y = -18135;
					console.log('perspectiveCamera.position.y', perspectiveCamera.position.y)
					console.log('perspectiveCamera.position.x', perspectiveCamera.position.x)



					// var box = new THREE.Box3().setFromObject( model );
					// var size = new THREE.Vector3();
					// box.getSize( size );
					// var scaleVec = new THREE.Vector3().divide( size );
					// var scale = Math.min( scaleVec.x, Math.min( saleVec.y, scaleVec.z ));

					// objectModel.scale.set(0.1, 0.1, 0.1)
					objectModel.scale.set(0.2, 0.2, 0.2);

					var decimationAmount = document.getElementById("txtDecimate").value;


					//count the triangles in the scene
					object.traverse(function (node) {
						if (node instanceof THREE.Mesh)//make sure the child is part of the model and not stuff that compilers add in
						{
							startVertexes += node.geometry.attributes.position.count / 3;
							node.material.wireframe = modelWireframe;
							node.material.flatShading = modelFlatShading;

							//node.geometry.computeFaceNormals();
							//node.geometry.computeVertexNormals();

							node.updateMatrix();

							// console.log(node.material.map.image.currentSrc);
						}
					});

					document.getElementById("txtVertex").value = startVertexes;
					document.getElementById("txtNewVertex").value = Math.floor(startVertexes * (decimationAmount / 100));

					scene.add(object);

				});
			});


			animate();

			const controls = new OrbitControls(perspectiveCamera, renderer.domElement);
			controls.target.set(0, 0.9, 0);

			//controls.update() must be called after any manual changes to the camera's transform
			controls.update();
		}


		//Creates a download link to download the file
		// const link = document.createElement( 'a' );
		// link.style.display = 'none';
		// document.body.appendChild( link );



		/**---------------------------------------Drag and Drop functionality---------------------------------------------.*/
		const toBase64 = file => new Promise((resolve, reject) => {

			const reader = new FileReader()

			reader.readAsDataURL(file)

			reader.onload = () => resolve(reader.result)
			reader.onerror = error => reject(error)

		})

		async function getDataUrl(file) {
			return await toBase64(file);
		}

		function dragAndDrop(inputElement) {

			var inputFiles = inputElement.files
			var imageTexture = []
			var a

			for (a = 0; a < inputFiles.length; a++) {
				if (!inputFiles[a].name.match('.obj') && !inputFiles[a].name.match('.mtl')) 
				{

					var name = inputFiles[a].name
					var image = URL.createObjectURL(inputFiles[a]).replace(window.location.origin, '').replace('blob:/', '');
					imageTexture.push({ name, image })

				}

			}

			for (a = 0; a < inputFiles.length; a++) {
				if (inputFiles[a].name.match('.obj'))
				{

					var url = URL.createObjectURL(inputFiles[a]);
					modelPath = url

				}
				else if (inputFiles[a].name.match('.mtl')) 
				{
					try 
					{

						var file = inputFiles[a]
						var fileReader = new FileReader()
						var newFile, url, blob, imageCount

						fileReader.readAsText(file);
						fileReader.onload = function () {

							newFile = this.result

							for (imageCount = 0; imageCount < imageTexture.length; imageCount++) {
								newFile = newFile.replace(imageTexture[imageCount].name, imageTexture[imageCount].image)
							}

							blob = new Blob([newFile], { type: "model/mtl;charset=utf-8" });

							url = URL.createObjectURL(blob);
							mtlPath = url

						}

					} 
					catch (error) 
					{
						console.log(error)
					}
				}
			}



			setTimeout(function () {	
				init();
			}, 3000)
		}
		/**--------------------------------------- // Drag and Drop functionality END---------------------------------------------.*/

		document.querySelectorAll(".drop-zone__input").forEach((inputElement) => {

			const dropZoneElement = inputElement.closest(".drop-zone");

			dropZoneElement.addEventListener("click", (e) => {
				inputElement.click();
			});

			inputElement.addEventListener("change", (e) => {
				dragAndDrop(inputElement)
			});

			dropZoneElement.addEventListener("dragover", (e) => {
				e.preventDefault();
				dropZoneElement.classList.add("drop-zone--over");

			});

			["dragleave", "dragend"].forEach((type) => {
				dropZoneElement.addEventListener(type, (e) => {
					dropZoneElement.classList.remove("drop-zone--over");
				});
			});

			dropZoneElement.addEventListener("drop", (e) => {
				e.preventDefault();
				dropZoneElement.classList.remove("drop-zone--over");
				dragAndDrop(inputElement)
			});

		});

		document.getElementById('glbDownload').addEventListener('click', function () {
			exportGLTF(scene);
		});

		document.getElementById('btnDecimate').addEventListener('click', function () {
			//var modifier = new simplifyMesh();

			var decimationAmount = document.getElementById("txtDecimate").value;
			scene.clear();

			console.log(modelName + ' is ready for decimation');

			var modelOptimized = objectModel.clone();

			modelOptimized.traverse(function (node) {

				if (node instanceof THREE.Mesh)//make sure the child is part of the model and not stuff that compilers add in
				{
					node.updateMatrix();

					var oldMaterialToMerge = node.material.map.image.currentSrc;

					var newTriangleAmount = Math.floor((node.geometry.attributes.position.count / 3) * (decimationAmount / 100));

					//var nodeToGeometry = new Geometry().fromBufferGeometry( node.geometry );

					node.geometry = modifier.modify(node.geometry, newTriangleAmount);
					node.geometry.computeFaceNormals();

					node.material.flatShading = modelFlatShading;
					node.material.wireframe = modelWireframe;
					node.needsUpdate = true;

					var oldMaterialToMerge = new THREE.MeshStandardMaterial({ map: new THREE.TextureLoader().load(oldMaterialToMerge) });

					textureLoader.crossOrigin = "";
					textureLoader.load(node.material.map.image.currentSrc,
						function (texture) {
							texture.minFilter = THREE.NearestFilter;
							var material = new THREE.MeshPhongMaterial({ map: texture, side: THREE.DoubleSide });
							console.log(material);
							var myBox2mesh = new THREE.Mesh(node.geometry, material);
							// add mesh to scene:
							//scene.add( myBox2mesh );
						}
					);

					node.updateMatrix();

				}

				scene.add(node);
			});



			const ambientLight = new THREE.AmbientLight(0xc9c9c9, 0.9);
			scene.add(ambientLight);
			scene.add(perspectiveCamera);

			animate();
		});

		document.getElementById('txtDecimate').addEventListener('change', function () {
			var decimationAmount = document.getElementById("txtDecimate").value;

			if (decimationAmount > 99) {
				document.getElementById("txtDecimate").value = 99;
			}
			else if (decimationAmount < 1) {
				document.getElementById("txtDecimate").value = 1;
			}

			decimationAmount = document.getElementById("txtDecimate").value;

			var startVertexes = document.getElementById("txtVertex").value;
			document.getElementById("txtNewVertex").value = Math.floor(startVertexes * (decimationAmount / 100));


		});


	</script>
</body>

</html>